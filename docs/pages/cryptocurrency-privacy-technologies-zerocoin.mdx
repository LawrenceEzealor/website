# Cryptocurrency Privacy Technologies: Zerocoin

<p className="text-xs text-right">December ??, 2023 by [patrickd](/about#patrickd)</p>

import { Callout } from 'nextra/components'
import { Tabs } from 'nextra/components'
import { Timeline, Year } from '@components/timeline'
import { R, Reference, References } from '@components/references'

export function DetailBox({ title, children }) {
  return (
    <details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
      <summary>
        <strong className="text-lg">{title}</strong>
      </summary>
      <div className="nx-p-2">{children}</div>
    </details>
  )
}

Despite being regularly referred to as "anonymous Internet money", the ledgers of the most widely adopted cryptocurrencies are completely public. Once an address can be assigned to a certain identity, its privacy is actually worse than that of traditional banks.

This article explores the Zerocoin Protocol, the first anonymous cryptocurrency proposal supporting large anonymity sets. Initially suggested as an extension to Bitcoin, it was implemented in various alt-coins over the years. You most likely heard about it as Zcoin (XCZ).

## The Concept

In 2013 the [Zerocoin](https://zerocoin.org/media/pdf/ZerocoinOakland.pdf) whitepaper suggested extending the Bitcoin Protocol by introducing a distributed e-cash scheme. Such electronic cash protocols aim to preserve privacy similarly to physical bank notes, an idea first implemented in "Chaumian e-Cash" which was enabled by [Blind Signatures](/posts/2023/3/24/cryptocurrency-privacy-technologies-blind-signatures) but required a bank-like centralized entity. Zerocoin instead, is a distributed e-cash system that intended to use Bitcoin's blockchain as a public "bulletin board", maintaining a list of valid coins for which a coin's membership is proven in zero-knowledge.<R reference="23" />

This proposal would have effectively extended Bitcoin with a native laundry functionality. Practically, users would have been able to make use of new opcodes added to Bitcoin's scripting language in order to lock funds into the mix and redeem them at a later time without any clear connection between deposit and redemption. Although originally proposed for Bitcoin, it could be integrated into any cryptocurrency.

### Scheme

[Transaction graph]

As you may already know from the previous [Confidential Transactions article](/posts/2023/10/31/cryptocurrency-privacy-technologies-confidential-transaction-values), Bitcoins are not actually transacted "from one account to another". Rather than that, there exist Unspent Transaction Outputs (UTXOs) that each have a "Locking Script" (`ScriptPubKey`) associated with them. This script dictates the condition under which a UTXO can be spent. Typically, this condition is that the transaction's signer matches with the address specified in the Locking Script ("Pay-to-Public-Key-Hash"). The signer, having therefore proven ownership over the Bitcoin amount contained by the UTXO, may then spent it (or multiple of them) and create new UTXOs with different unlocking conditions (eg. such that only the new owner of the coins may spend them).

[Transaction graph with Zerocoin]

Zerocoin introduces a new such condition: A user may choose to specify a locking script in their UTXO which "mints" a Zerocoin. With this, the BTC value stays locked in within this UTXO while the creator receives a "Zerocoin" for which they may later redeem the value for. A commitment to the Zerocoin's unique identifier is added to the list of all Zerocoin commitments, and later the user may use this identifier to "spend" the Zerocoin in exchange for the locked value it represents. The crux is, that the user is able to prove that the identifier's commitment is within the list without revealing the specific commitment using a zero-knowledge proof. Having proven ownership, the user may now choose any mint-UTXO containing the appropriate value in exchange for their Zerocoin. By avoiding their own transaction which they used to mint the Zerocoin, it is no longer possible to trace the funds using Bitcoin's transaction graph.

<DetailBox title="Example">

To show how the protocol works, let's imagine Alice is owner over an UTXO holding a value of 2.4 BTC. She'd like to mint two Zerocoins each representing the denomination of 1 BTC. To do so, she locally generates two unique serial numbers $`S_a`$ and $`S_b`$ which she will keep secret until she decides to spend the coins. She signs a transaction containing 3 output UTXOs: One sending the change of 0.4 BTC back to herself and the other two each locking one BTC into the e-cash system. The Locking Scripts of these two Zerocoin-minting UTXOs contain commitments $`C_a`$ and $`C_b`$ which each commit to the yet to be revealed serial numbers. Bitcoin's blockchain now acts as a public bulletin board containing a set of commitments $`C_1, ..., C_N`$ each representing a minted Zerocoin of 1 BTC value. Basically, the protocol is acting as an escrow pool and it's possible to mint different kinds of Zerocoins for various denominations.

After waiting for a while for other users to participate in the e-cash system, Alice may decide to redeem a Zerocoin in exchange for any other UTXO locking 1 BTC for the Zerocoin protocol ($`C_x`$): Alice generates a proof $`pi_a`$ that shows she knows $`S_a`$ for a commitment within the set of all unspent commitments $`C_1, ..., C_N`$, without revealing which of the commitments the associated $`C_a`$ is. Alice signs a Transaction where she chose any Zerocoin-minting UTXO as input, "proved her ownership" over it using $`(S_a, pi_a)`$, and sends the unlocked BTC to a fresh address that has no known association with her. The protocol will keep record of all revealed serial numbers $`S`$ in order to prevent double spending. Alice was able to hide the origin of her funds within the anonymity set of all other Zerocoin holders.

</DetailBox>

<Callout>
  "[Burning Zerocoins for fun and profit](https://www.chaac.tf.fau.de/files/2018/04/attack-cryptocur.pdf)" reveals a fundamental flaw with using plaintext identifiers: An attacker observing transactions may notice a user's intention for spending a legitimate Zerocoin with serial number $`S`$. The attacker may quickly mint and redeem a Zerocoin with that very same serial number $`S`$ and, if they succeeded to do this before the user's spend transaction was included, it would now be rejected since the specified serial number has already been marked as "spent". The user's Zerocoin is then effectively unspendable and the user will not be able to redeem it for its value.

  The paper suggests using a public key as serial number instead, and adjusting the protocol to have the spender proof they know the appropriate private key by having them sign a message with it.
</Callout>

### Accumulators

Proving that an element is part of a list without revealing which, is a classical membership problem. We previously discussed [Ring Signatures](/posts/2023/9/27/cryptocurrency-privacy-technologies-ring-signatures/) which offer one solution to it, but they wouldn't allow the anonymity set to be very large: The size of a Ring Signature is linear to the number of ring members, not a good fit for what Zerocoin is attempting to achieve with including all commitments in the list.

Instead, Zerocoin makes use of an "accumulator": An algorithm that allows one to combine a set of values into one short value. For a value within the accumulator, there exists a witness $`w`$ that proofs the inclusion, while at the same time it is infeasible to find a witness for a value that was not accumulated.

An accumulator scheme most readers will be familiar with is likely "Merkle Trees": A binary hash tree where each two elements are hashed with each other repeatedly until reaching a "root hash", the accumulator value that is committed to all the items within the list. The witness ("Merkle Proof") for a single item would therefore be all the other hashes going up the tree that are necessary to reach the root without the necessity of mentioning all other leafs.<R reference="36" /> In "[Auditable, Anonymous Electronic Cash](https://www.cs.tau.ac.il/~amnon/Papers/ST.crypto99.pdf)" Sander and Ta–Shma used a zero-knowledge proof to show that an element is indeed contained within the tree without revealing the element itself.

Zerocoin itself uses an "RSA Accumulator" scheme which, like Merkle Trees allow everyone to reproduce the accumulation of values without the need of knowing any secret trapdoor information. Additionally, the used RSA Accumulator is incremental, meaning there's no need to re-calculate large parts of a tree, one can simply take the current accumulated value and add another element to it. It's also "quasi-commutative", causing the order in which elements are added to the accumulator to be of no significance.

<Callout>
  The incremental nature of RSA Accumulators is used to optimize Zerocoin: Each of Bitcoin's blocks would have had an "Accumulator Checkpoint", which is simply the final accumulated value after processing all transactions included within the block. Most clients can continue off this checkpoint instead of having to calculate the entire accumulator themselves.
</Callout>

Creating an empty accumulator $`Lambda`$:

$`Lambda = tt"setup"()`$

Incrementally adding a commitment $`C`$ to the accumulator, yields an updated accumulator value:

$`Lambda' = tt"add"(Lambda, C)`$

The order in which commitments are added is irrelevant:

$`tt"add"(tt"add"(Lambda, C_2), C_1) = tt"add"(tt"add"(Lambda, C_1), C_2)`$

By knowing the accumulator value $`Lambda`$ before a commitment $`C`$ was added, it's possible to generate a witness proving that $`C`$ was added to the accumulator resulting in $`Lambda'`$

$`w = tt"generateWitness"(Lambda, C)`$

$`Lambda' = tt"add"(Lambda, C)`$

$`tt"verifyWitness"(Lambda', C, w) =`$ $\texttt{true}$

<DetailBox title="Toy Example">

As a toy example, imagine the accumulator is a composite number while all its elements are prime numbers. As you may remember, all integers that aren't prime must be composite numbers which can be factored into a unique collection of prime numbers. (eg. $`15`$ is not prime, therefore, it must be a composite number and can be represented by its prime factors: $`3 * 5 = 15`$)

After initializing the accumulator with $`Lambda = setup() = 1`$ we can now add a few primes to the set:

$`Lambda = tt"add"(Lambda, 5) = 1 * 5 = 5`$

$`Lambda = tt"add"(Lambda, 17) = 5 * 17 = 85`$

$`Lambda = tt"add"(Lambda, 3) = 85 * 3 = 255`$

The accumulator $`Lambda`$ is the composite of all the prime numbers added to the set: $`5, 17, 3`$.

A witness $`w`$ can simply be the state of the accumulator before the number in question was added:

$`w = tt"generateWitness"(Lambda, 11) = Lambda`$

$`Lambda' = tt"add"(Lambda, 11) = 255 * 11 = 2805`$

$`tt"verifyWitness"(Lambda', 11, w) = (w*11 \stackrel{?}{=} Lambda') =`$ $\texttt{true}$

</DetailBox>

### Interactive Zero Knowledge proofs

The zero-knowledge proofs described in the paper can be instantiated using the technique of Schnorr<R reference="12" />. Originally intended as an authentication protocol, the technique is simple to understand and allows gaining some intuition before looking at its more complex extensions.<R reference="11" />
 
<Tabs items={['Conventional DLP (Exponential Notation)', 'ECDLP (ECC Notation)']} defaultIndex="0">
<Tabs.Tab>

Assume we have an agreed upon generator $`g in ZZ_p`$ within a multiplicative cyclic group of order $`q`$ for which the Discrete Logarithm Problem is hard.

$`v = g^(-color(red)(s))" "("mod " p)`$

Schnorr's interactive authentication protocol allows the possessor of a random secret key $`color(red)(s)`$ of public key $`v`$ to prove knowledge of $`color(red)(s)`$ without revealing anything about it.

$`bb"ZKPoK"{(color(red)(s)): v = g^(-color(red)(s))}`$

| Prover                                                 | Verifier                                        |
| -----------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, v, color(red)(s))`$                        | Knows $`(g, v)`$                                |
| Chooses a random value $`color(red)(r)`$               |                                                 |
| $`x = g^color(red)(r)" "("mod " p)`$                   |                                                 |
| Sends $`x Rightarrow`$                                 | Knows $`(g, v, x)`$                             |
|                                                        | Chooses a random challenge value $`e`$          |
| Knows $`(g, v, color(red)(s), color(red)(r), x, e)`$   | $`Leftarrow`$ Sends $`e`$                       |
| $`y = color(red)(r) + color(red)(s)*e " "("mod " q)`$  |                                                 |
| Sends $`y Rightarrow`$                                 | Knows $`(g, v, x, e, y)`$                       |
|                                                        | $`x" "\stackrel{?}{=}" "g^y*v^e" "("mod " p)`$  |

With the Discrete Logarithm Problem being hard, the verifier cannot determine $`color(red)(s)`$ or $`color(red)(r)`$ from $`v`$ and $`x`$ respectively, but is able to check that $`y`$ was computed honestly because 

$`x = g^y * v^e`$

$`g^color(red)(r) = g^(color(red)(r)+color(red)(s)*e) * (g^-color(red)(s))^e`$

$`g^color(red)(r) = g^((color(red)(r)+cancel(color(red)(s)*e)) + cancel((-color(red)(s)*e)))`$

A prover would only be able to determine a legitimate value $`y`$ by knowing the actual values of its components ($`color(red)(r) + color(red)(s)*e`$). A malicious prover attempting to authenticate for a $`v`$ is, just like the verifier, unable to extract $`color(red)(s)`$ due to DLP. But knowing the value $`color(red)(s)`$ is required for coming up with a valid $`y`$ value.

Looking at $`y`$, you should also be able to notice why it's important that the verifier adds randomness with $`color(red)(r)`$. After all, if it were simply $`y = color(red)(s) * e`$, the verifier would be able to extract $`color(red)(s)`$ simply by division of known values: $`color(red)(s) = y / e" "("mod " q)`$

<Callout>
  To perform modular division, one has to multiply with the multiplicative inverse of the divisor within the modulus: $`s = y * e^(-1)" "("mod " q)`$
</Callout>

Lastly, it's essential that the prover is challenged with $`e`$. If a prover were able to guess $`e`$ before committing to a specific $`x`$, the prover could choose to calculate an $`x = g^y * v^e`$ (with a randomly chosen $`y`$) without knowing $`s`$. This $`x`$ would pass verification and allow the prover to fake knowledge about about any public key's secret value.

<Callout type="warning">
  Conventional DLP is a lot more fragile than ECDLP and requires choosing many of the above parameters very carefully.
</Callout>

</Tabs.Tab>
<Tabs.Tab>

Assume we have an agreed upon generator point $`G`$ within an additive cyclic group of order $`n`$ for which the Elliptic Curve Discrete Logarithm Problem is hard.

$`V = color(red)(s)*G`$

Schnorr's interactive authentication protocol allows the possessor of a random secret scalar $`color(red)(s)`$ of public key $`V`$ to prove knowledge of $`color(red)(s)`$ without revealing anything about it.

$`bb"ZKPoK"{(color(red)(s)): V = color(red)(s)*G}`$

| Prover                                                 | Verifier                                  |
| -----------------------------------------------------: | :---------------------------------------- |
| Knows $`(G, V, color(red)(s))`$                        | Knows $`(G, V)`$                          |
| Chooses a random scalar $`color(red)(r)`$              |                                           |
| $`X = color(red)(r)*G`$                                |                                           |
| Sends $`X Rightarrow`$                                 | Knows $`(G, V, X)`$                       |
|                                                        | Chooses a random challenge scalar $`e`$   |
| Knows $`(G, V, color(red)(s), color(red)(r), X, e)`$   | $`Leftarrow`$ Sends $`e`$                 |
| $`y = color(red)(r) + color(red)(s)*e " "("mod " n)`$  |                                           |
| Sends $`y Rightarrow`$                                 | Knows $`(G, V, X, e, y)`$                 |
|                                                        | $`y*G" "\stackrel{?}{=}" "X+e*V`$         |

With the Discrete Logarithm Problem being hard, the verifier cannot determine $`color(red)(s)`$ or $`color(red)(r)`$ from $`V`$ and $`X`$ respectively, but is able to check that $`y`$ was computed honestly because 

$`y*G = X+e*V`$

$`(color(red)(r) + color(red)(s)*e)*G = (color(red)(r)*G)+e*(color(red)(s)*G)`$

$`(color(red)(r) + color(red)(s)*e)*G = (color(red)(r) + color(red)(s)*e)*G`$

A prover would only be able to determine a legitimate scalar $`y`$ by knowing the actual values of its components ($`color(red)(r) + color(red)(s)*e`$). A malicious prover attempting to authenticate for a $`V`$ is, just like the verifier, unable to extract $`color(red)(s)`$ due to ECDLP. But knowing the scalar $`color(red)(s)`$ is required for coming up with a valid $`y`$ value.

Looking at $`y`$, you should also be able to notice why it's important that the verifier adds randomness with $`color(red)(r)`$. After all, if it were simply $`y = color(red)(s) * e`$, the verifier would be able to extract $`color(red)(s)`$ simply by division of known values: $`color(red)(s) = y / e" "("mod " n)`$

<Callout>
  To perform modular division, one has to multiply with the multiplicative inverse of the divisor within the modulus: $`s = y * e^(-1)" "("mod " n)`$
</Callout>

Lastly, it's essential that the prover is challenged with $`e`$. If a prover were able to guess $`e`$ before committing to a specific $`X`$, the prover could choose to calculate the "difference" $`yG - eV`$ (with a randomly chosen $`y`$) and send it as $`X`$. This difference would be added during verification and allow the prover to fake knowledge about about any public key's secret scalar.

</Tabs.Tab>
</Tabs>

### Making Interactive Proofs Non-Interactive

<Tabs items={['Conventional DLP (Exponential Notation)', 'ECDLP (ECC Notation)']} defaultIndex="0">
<Tabs.Tab>

Interactive proofs are not publicly verifiable. The prover proved knowledge of $`color(red)(s)`$ to the verifier, but not to anyone else. But this can be changed since, according to a transcript of the interaction, the verifier's sole purpose is producing a random challenge. By replacing the verifier as random oracle with a hash function, for which there is no known way to distinguish a result from random, the prover is able to generate the challenge themselves while having it remain provably random.

$`e = tt"hash"(x)`$

This makes the Interactive Proof transcript publicly verifiable without requiring a 1-to-1 interaction with any specific verifier. This idea of replacing an actual challenger with a random oracle is known as the Fiat-Shamir transform<R reference='17' /> and turns the interactive Schnorr authentication protocol into the Schnorr signature scheme: With a hash function returning a different challenge $`e`$ for different inputs, it's possible to add (by concatenation) more data to the input.

$`e = tt"hash"(m\|\|x)`$

The resulting transcript containing $`m`$, for which $`m`$ cannot be changed without knowledge of $`color(red)(s)`$, is therefore a "signature of knowledge" on $`m`$.

$`bb"ZKSoK"[m]{(color(red)(s)): v = g^(-color(red)(s))}`$

| Prover                                                 | Verifier                                        |
| -----------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, v, color(red)(s))`$                        | Knows $`(g, v)`$                                |
| Chooses a random value $`color(red)(r)`$               |                                                 |
| $`x = g^color(red)(r)" "("mod " p)`$                   |                                                 |
| $`e = tt"hash"(m\|\|x)`$                               |                                                 |
| $`y = color(red)(r) + color(red)(s)*e " "("mod " q)`$  |                                                 |
| Sends $`(e, y, m) Rightarrow`$                         | Knows $`(g, v, e, y, m)`$                       |
|                                                        | $`x = g^y * v^e`$                               |
|                                                        | $`e" "\stackrel{?}{=}" "tt"hash"(m\|\|x)`$      |

$`x = g^y * v^e`$

$`g^color(red)(r) = g^(color(red)(r) + color(red)(s)*e) * (g^-color(red)(s))^e`$

$`g^color(red)(r) = g^(color(red)(r) + cancel(color(red)(s)*e) cancel(-color(red)(s)*e))`$

$`g^color(red)(r) = g^color(red)(r)`$

One obvious drawback of non-interactive proofs of knowledge is that they can no longer be used for authentication since they can fundamentally be replayed.

</Tabs.Tab>
<Tabs.Tab>

Interactive proofs are not publicly verifiable. The prover proved knowledge of $`color(red)(s)`$ to the verifier, but not to anyone else. But this can be changed since, according to a transcript of the interaction, the verifier's sole purpose is producing a random challenge. By replacing the verifier as random oracle with a hash function, for which there is no known way to distinguish a result from random, the prover is able to generate the challenge themselves while having it remain provably random.

$`e = tt"hash"(X)`$

This makes the Interactive Proof transcript publicly verifiable without requiring a 1-to-1 interaction with any specific verifier. This idea of replacing an actual challenger with a random oracle is known as the Fiat-Shamir transform<R reference='17' /> and turns the interactive Schnorr authentication protocol into the Schnorr signature scheme: With a hash function returning a different challenge $`e`$ for different inputs, it's possible to add (by concatenation) more data to the input.

$`e = tt"hash"(m\|\|X)`$

The resulting transcript containing $`m`$, for which $`m`$ cannot be changed without knowledge of $`color(red)(s)`$, is therefore a "signature of knowledge" on $`m`$.

$`bb"ZKSoK"[m]{(color(red)(s)): V = color(red)(s)*G}`$

| Prover                                                 | Verifier                                  |
| -----------------------------------------------------: | :---------------------------------------- |
| Knows $`(G, V, color(red)(s), m)`$                     | Knows $`(G, V)`$                          |
| Chooses a random scalar $`color(red)(r)`$              |                                           |
| $`X = color(red)(r)G`$                                 |                                           |
| $`e = tt"hash"(m\|\|X)`$                               |                                           |
| $`y = color(red)(r) + color(red)(s)*e " "("mod " n)`$  |                                           |
| Sends $`(e, y, m) Rightarrow`$                         | Knows $`(G, V, e, y, m)`$                 |
|                                                        | $`X = yG - eV`$                           |
|                                                        | $`e" "\stackrel{?}{=}" "tt"hash"(m\|\|X)`$|

$`X = yG - eV`$

$`color(red)(r)G = (color(red)(r) + color(red)(s)*e)G - e*(color(red)(s)G)`$

$`color(red)(r)G = (color(red)(r) + cancel(color(red)(s)*e) - cancel(e*color(red)(s)))G`$

$`color(red)(r)G = color(red)(r)G`$

One obvious drawback of non-interactive proofs of knowledge is that they can no longer be used for authentication since they can fundamentally be replayed.

</Tabs.Tab>
</Tabs>

<Callout type="info">
  The ECC Notation may be more intuitive for some readers, but since we're not dealing with points on curves in this article, further descriptions will make use of the Exponential Notation instead.
</Callout>

## The Math

### Strong RSA Accumulator

Having covered RSA intuition in a [previous article](/posts/2023/3/23/why-does-rsa-actually-work/), we'll not go into much detail here. The important parts are that RSA relies on prime factorization being hard for two carefully chosen primes $`n = hat p * hat q`$, and that going backwards from having calculated $`e -= m^e" "("mod "n)`$ is really hard without knowledge of trapdoor information.

With RSA's ability to provide unpredictable one-way permutations, like a conventional hashing function, we can accumulate commitments by modular exponentiation:

$$
`Lambda' = Lambda^C" "("mod "n)`
$$

We can even accumulate multiple commitments at once by multiplying them:

$$
`(((Lambda^(C_1))^(C_2))^("..."))^(C_n) = Lambda^(C_1 * C_2 *" ... "* C_n)" "("mod "n)`
$$

For this accumulator to be considered "strong" it needs to be collision-free. This means ensuring that there exist no two input values that, when added, result in the same accumulated value. Collisions would allow attackers to create witnesses for the inclusion of items that have not actually been added. This issue is avoided by ensuring that all commitments are prime.<R reference='23' />

#### Trusted Setup

To initialize the accumulator we need two random primes $`hat p`$ and $`hat q`$. To strengthen against attacks we wouldn't choose these directly, instead we'll randomly generate prime numbers $`hat p'`$ and $`hat q'`$ until the following conditions are met:

$$
`hat p = 2*hat p' + 1`
$$
$$
`hat q = 2*hat q' + 1`
$$
$$
`hat p, hat q, hat p', hat q'" are all odd primes"`
$$

Parameters $`hat p`$, $`hat q`$ generated like this are considered "safe primes" while $`hat p'`$ and $`hat q'`$ are referred to as Sophie Germain primes. This makes $`n = hat p hat q`$ a "rigid integer" and very hard to factor.<R reference='13' />

After calculating $`n = hat p * hat q`$ within a trusted environment, $`hat p`$ and $`hat q`$ are no longer needed. In fact, they're toxic waste and should be destroyed immediately because the consequences of them leaking is that someone could forge Zerocoin spend transactions.<R reference='21' />

<Callout>
  In other RSA Accumulator use-cases with a trusted centralized party, this trapdoor information is actually useful: It allows removing a value $`C`$ that is accumulated within $`Lambda`$ by calculating
  $`Lambda' = Lambda^((C^(-1)" mod("phi(n)")")) " mod("n")`$ where $`phi(n) = (hat p - 1)*(hat q - 1)`$.
</Callout>

Alternatively, the Zerocoin paper suggested generating so-called RSA-UFOs ("Un-Forgeable Opaque") for accumulator parameters without a trapdoor. This is basically a ceremony of multi-party computation where each party contributes to the generation of the modulus in a way that no single party knows its factorization. The resulting modulus $`n`$ should, with very high probability, have two large factors.<R reference='37' />

Most Zerocoin implementations, including Zcoin, opted for neither of these setups. Instead, they utilized the RSA-2048 parameters generated in 1991 from the [RSA factoring challenge](https://web.archive.org/web/20130921043454/http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-factoring-challenge-faq.htm), which had a USD200,000 prize if someone managed to factor them. The challenge ended in 2007 with nobody claiming the prize, but this still requires trusting the challenge organizers to truly having destroyed trapdoor information after generation.

Lastly, we need to choose the accumulator's initial value $`Lambda = u`$, with $`u != 1`$ and $`u in QR_n`$. To find such a Quadratic Residue we calculate $`u -= x^2" "("mod "n)`$ where $`x`$ can be a random value or something specific such as a representation of the current date. Although no further explanation on this was given, I assume it is because squaring does not create a permutation of the entire group modulo $`n`$ as it only maps to quadratic residues and then won't impact the accumulator.<R reference='10' />


### Pedersen Commitment

When minting a Zerocoin, a commitment needs to be added to the appropriate accumulator. We've already introduced Pedersen Commitments in the exploration of [Confidential Transactions](/posts/2023/10/31/cryptocurrency-privacy-technologies-confidential-transaction-values/#pedersen-commitment). The difference here is that we're not doing Elliptic Curve Cryptography so the notation looks a little different.

$$
`C = g^S * h^r" "("mod "p)`
$$

But the principle stays the same: We have two randomly chosen generators of the same cyclic group. We use the second generator to add a random blinding factor $`r`$ to ensure that the committed serial number $`S`$ can not be guessed with brute force. Furthermore, we'll only reveal $`S`$ to prevent double-spending of Zerocoins, the blinding factor must remain secret as otherwise the commitment can be reconstructed and you'd be able to draw a connection between the minting (reveals commitment $`C`$) and the spending (reveals identifier $`S`$) transactions, breaking anonymity.

Since Strong RSA Accumulators only allow prime numbers to be added, we may need a few attempts to find a pair $`(S, r)`$ for which the resulting pedersen commitment is prime.

<Callout type="info">
  Note that the modulus $`p`$ used for the Pedersen Commitment is unrelated to the RSA Accumulator, though similar in its creation: $`p = 2^(omega) * q + 1`$ where both $`p, q`$ are prime with $`omega >= 1`$. Generators $`g, h`$ are of the subgroup $`ZZ_q^(**)`$ from which the random values for $`S, r`$ are taken.
</Callout>

### Zero-knowledge Proofs

So far, we've learned how to initialize an Accumulator $`Lambda`$, and how to create a prime commitment $`C`$ to a Zerocoin's serial number $`S`$, blinded by a random value $`r`$. By remembering the accumulator's state before adding the commitment, we generate a witness $`w = Lambda`$ that we can use to prove inclusion of the commitment in $`Lambda' = Lambda^C`$. These are the techniques necessary in order to lock some BTC into the mixing pool and "mint" an appropriate Zerocoin in exchange.

In order to redeem the Zerocoin later, we'd have to prove that (1) our coin's commitment $`C`$ is indeed included within the Accumulator $`Lambda'`$, and (2) that the unspent Serial number $`S`$ we're revealing was indeed the one that was committed to. But, in order to stay anonymous, we must prove this without revealing $`C`$, $`w`$, or $`r`$ since any of these would allow connecting the redemption to the transaction that minted the Zerocoin. 

To accomplish this, the paper described the following Zero Knowledge Signature of Knowledge $`pi`$ on transaction data $`bb"T"`$:

$$
`pi = bb"ZKSoK[T]"{(color(red)(C), color(red)(w), color(red)(r)): tt"verifyWitness"(Lambda', color(red)(C), color(red)(w)) = tt"true" ^^ color(red)(C) = g^S*h^color(red)(r)}`
$$

#### Proof of Accumulator Inclusion

For the first part, proving that a committed value is accumulated, the Zerocoin paper and other publications omit detailed explanations and instead refer the reader to the original protocol presented by Camenisch and Lysyanskaya.<R reference='8' /> They summarize that the described proof is then converted into a Non-Interactive Zero-Knowledge Proof of Knowledge via Fiat-Shamir transform:

$$
`bb"NIZKPoK"{(color(red)(C), color(red)(w)): tt"verifyWitness"(Lambda', color(red)(C), color(red)(w)) = tt"true"}`
$$

<Callout>
  The authors consider the described Zero-Knowledge Proof of Knowledge efficient; although the large proof sizes and the resulting inefficiencies are arguably one of Zerocoin's biggest drawbacks. But still, compared to an inclusion proof that, like Ring Signatures, grows linearly with each member within the group, the used proof is indeed much more efficient.
</Callout>

To construct the proof, we once again need to make use of a pedersen commitment $`CC_Lambda`$, which commits to the commitment $`C`$ which was added to the accumulator as a value. The proof then works by showing that the value $`C`$ is contained in both the commitment $`CC_Lambda`$ as well as within the accumulator $`Lambda`$ without revealing $`C`$. Only the new commitment $`CC_Lambda`$ has to be revealed as part of this protocol.

$$
`CC_Lambda = g^C*h^r`
$$

<Callout type="info">
  In addition to being prime, further restrictions on the choice of the $`C`$ commitment values are necessary to ensure the proofs security: First, commitments must be within a sub-range $`chi_(A,B)`$ as $`2 < A <= C <= B < A^2`$ to guarantee that the product of any two commitments falls outside of the range.<R reference='20' /> Second, for $`chi_(A,B)`$ and the choice of $`q`$ it's required that $`B*2^(lambda'+lambda''+2) < A^2 - 1 < q/2`$ holds, where $`lambda', lambda''`$ are adjustable security parameters.
</Callout>

Next, we need a few more auxiliary (helper) commitments. These don't make use of the same generators as $`CC_Lambda`$ though, instead $`tilde g, tilde h`$ are two elements from $`QR_n`$ (quadratic residues within the accumulator's modulo $`n`$) for which $`log_(g)(h)`$ is unknown (similarly to how in ECC the relationship $`H = x*G`$ must remain unknown in order to prevent the prover from tempering with the committed values). The blinding factors $`r_1, r_2, r_3`$ are chosen randomly from $`ZZ_([n/4])`$.

| Prover                                                                | Verifier                                        |
| --------------------------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, h, n, tilde g, tilde h, Lambda', CC_Lambda, color(red)(r), color(red)(C), color(red)(w))`$     | Knows $`(g, h, n, tilde g, tilde h, Lambda', CC_Lambda)`$ |
| Chooses random values $`(color(red)(r_1, r_2, r_3))`$                 | |
| $`tilde CC_C = tilde g^color(red)(C)*tilde h^(color(red)(r_1))`$      | |
| $`tilde CC_(w) = color(red)(w)*tilde h^(color(red)(r_2))`$            | |
| $`tilde CC_r = tilde g^(color(red)(r_2))*tilde h^(color(red)(r_3))`$  | |
| Sends $`(tilde CC_C, tilde CC_(w), tilde CC_r) Rightarrow`$           | Knows $`(g, h, n, tilde g, tilde h, Lambda', CC_Lambda, tilde CC_C, tilde CC_(w), tilde CC_r)`$ |

Like $`CC_Lambda`$, the auxiliary commitment $`tilde CC_C`$ commits to $`C`$, the value accumulated by $`Lambda'`$. Additionally, $`tilde CC_w`$ commits to witness $`w`$ and will be used to prove that it corresponds to the $`C`$-th root value $`Lambda'`$ ($`Lambda' = Lambda^C = w^C hArr root(C)(Lambda') = w`$).

| Prover                                                                | Verifier                                        |
| --------------------------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, h, n, tilde g, tilde h, CC_Lambda, Lambda', tilde CC_C, tilde CC_(w), tilde CC_r, color(red)(r), color(red)(C), color(red)(w))`$ | Knows $`(g, h, n, tilde g, tilde h, CC_Lambda, Lambda', tilde CC_C, tilde CC_(w), tilde CC_r)`$ |
| Chooses random values $`(color(red)(alpha, beta, gamma, delta, epsilon, zeta, varphi, psi, eta), sigma, xi)`$ | |
| $`t_1 = g^color(red)(alpha)*h^color(red)(varphi)`$                    | |
| $`t_2 = (CC_Lambda/g)^color(red)(gamma)*h^color(red)(psi)`$                  | |
| $`t_3 = (gCC)^sigma*h^xi`$                                            | |
| $`tilde t_1 = tilde h^color(red)(epsilon)*tilde g^color(red)(zeta)`$  | |
| $`tilde t_2 = tilde h^color(red)(alpha)*tilde g^color(red)(eta)`$     | |
| $`tilde t_3 = (tilde CC_w)^color(red)(alpha)*tilde h^-color(red)(beta)`$ | |
| $`tilde t_4 = (tilde CC_r)^color(red)(alpha)*tilde h^-color(red)(delta)*tilde g^-color(red)(beta)`$ | |
| Sends $`(t_1, t_2, t_3, tilde t_1, tilde t_2, tilde t_3, tilde t_4) Rightarrow`$ | Knows $`(..., t_1, t_2, t_3, tilde t_1, tilde t_2, tilde t_3, tilde t_4)`$ |
|                                                                       | Chooses a random challenge $`e in {0,1}^lambda`$ |
| Knows $`(..., e)`$                                                    | $`Leftarrow`$ Sends $`e`$ 
| $`bar alpha = color(red)(alpha) - e*color(red)(C)`$                   | |
| $`bar beta = color(red)(beta) - e*color(red)(r_2*C)`$                 | |
| $`bar zeta = color(red)(zeta) - e*color(red)(r_3)`$                   | |
| $`bar eta = color(red)(eta) - e*color(red)(r_1)`$                     | |
| $`bar epsilon = color(red)(epsilon) - e*color(red)(r_2)`$             | |
| $`bar delta = color(red)(delta) - e*color(red)(r_3*C)`$               | |
| $`bar varphi = color(red)(varphi) - e*color(red)(r)`$                 | |
| $`bar gamma = color(red)(gamma) - e*(color(red)(C) - 1)^-1`$          | |
| $`bar psi = color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1`$| |
| $`bar sigma = sigma - e*(color(red)(C) + 1)^-1`$                      | |
| $`bar xi = xi - e*color(red)(r)*(color(red)(C) + 1)^-1`$              | |
| Sends $`(bar alpha, bar beta, bar gamma, bar delta, bar epsilon, bar zeta, bar varphi, bar psi, bar eta, bar sigma, bar xi) Rightarrow`$ | Knows $`(..., bar alpha, bar beta, bar gamma, bar delta, bar epsilon, bar zeta, bar varphi, bar psi, bar eta, bar sigma, bar xi)`$ |
|                                                                       | $`t_1" "overset(?)(=)" "(CC_Lambda)^e*g^(bar alpha)*h^(bar varphi) `$ |
|                                                                       | $`t_2" "overset(?)(=)" "g^e*(CC_Lambda/g)^(bar gamma)*h^(bar psi)`$ |
|                                                                       | $`t_3" "overset(?)(=)" "g^e*(gCC)^(bar sigma)*h^(bar xi)`$ |
|                                                                       | $`tilde t_1" "overset(?)(=)" "(tilde CC_r)^e*tilde h^(bar epsilon)*tilde g^(bar zeta)`$ |
|                                                                       | $`tilde t_2" "overset(?)(=)" "(tilde CC_C)^e*tilde h^(bar alpha)*tilde g^(bar eta)`$ |
|                                                                       | $`tilde t_3" "overset(?)(=)" "(Lambda')^e*(tilde CC_w)^(bar alpha)*tilde h^(-bar beta)`$ |
|                                                                       | $`tilde t_4" "overset(?)(=)" "(tilde CC_r)^(bar alpha)*tilde h^(-bar delta)*tilde g^(-bar beta)`$ |
|                                                                       | $`bar alpha" "overset(?)(in)" "[-B*2^(lambda'+lambda''+1), B*2^(lambda'+lambda''+1)]`$ |

<Callout type="info">
  Note that the above calculations are within $`"(mod "q")"`$ and that the random exponents have to be selected as follows: $`alpha in (-B*2^(lambda'+lambda''), ..., B*2^(lambda'+lambda'')), gamma, varphi, psi, sigma, xi in ZZ_q, epsilon, eta, zeta in (-|__n/4__|*2^(lambda'+lambda''), ..., |__n/4__|*2^(lambda'+lambda'')), and beta, delta in (-|__n/4__|*q2^(lambda'+lambda''), ..., |__n/4__|*q2^(lambda'+lambda''))`$.
</Callout>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`t_1" "overset(?)(=)" "(CC_Lambda)^e*g^(bar alpha)*h^(bar varphi)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_1 = g^color(red)(alpha)*h^color(red)(varphi)" , "CC_Lambda = g^color(red)(C)*h^color(red)(r)" , "bar alpha = color(red)(alpha) - e*color(red)(C)" , "bar varphi = color(red)(varphi) - e*color(red)(r)`$

    $`g^color(red)(alpha)*h^color(red)(varphi)" "overset(?)(=)" "(g^color(red)(C)*h^color(red)(r))^e * g^(color(red)(alpha) - e*color(red)(C)) * h^(color(red)(varphi) - e*color(red)(r))`$

    $`g^color(red)(alpha)*h^color(red)(varphi)" "overset(?)(=)" "g^(e*color(red)(C))*h^(e*color(red)(r)) * g^(color(red)(alpha) - e*color(red)(C)) * h^(color(red)(varphi) - e*color(red)(r))`$

    $`g^color(red)(alpha)*h^color(red)(varphi)" "overset(?)(=)" "g^(e*color(red)(C) + color(red)(alpha) - e*color(red)(C))*h^(e*color(red)(r) + color(red)(varphi) - e*color(red)(r))`$

    $`g^color(red)(alpha)*h^color(red)(varphi)" "overset(?)(=)" "g^(cancel(e*color(red)(C)) + color(red)(alpha) - cancel(e*color(red)(C)))*h^(cancel(e*color(red)(r)) + color(red)(varphi) - cancel(e*color(red)(r)))`$

    $`g^color(red)(alpha)*h^color(red)(varphi)" "overset(✓)(=)" "g^color(red)(alpha)*h^color(red)(varphi)`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`t_2" "overset(?)(=)" "g^e*(CC_Lambda/g)^(bar gamma)*h^(bar psi)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_2 = (CC_Lambda/g)^color(red)(gamma)*h^color(red)(psi)" , "CC_Lambda = g^color(red)(C)*h^color(red)(r)" , "bar gamma = color(red)(gamma) - e*(color(red)(C) - 1)^-1" , "bar psi = color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1`$

    $`(CC_Lambda/g)^color(red)(gamma)*h^color(red)(psi)" "overset(?)(=)" "g^e*(CC_Lambda/g)^(color(red)(gamma) - e*(color(red)(C) - 1)^-1)*h^(color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1)`$

    $`((g^color(red)(C)*h^color(red)(r))/g)^color(red)(gamma)*h^color(red)(psi)" "overset(?)(=)" "g^e*((g^color(red)(C)*h^color(red)(r))/g)^(color(red)(gamma) - e*(color(red)(C) - 1)^-1)*h^(color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1)`$

    $`g^color(red)(Cgamma) * h^color(red)(rgamma) * g^-color(red)(gamma) * h^color(red)(psi)" "overset(?)(=)" "g^e* g^(color(red)(C)(color(red)(gamma) - e*(color(red)(C) - 1)^-1)) * h^(color(red)(r)(color(red)(gamma) - e*(color(red)(C) - 1)^-1)) * g^-(color(red)(gamma) - e*(color(red)(C) - 1)^-1) * h^(color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1)`$

    $`g^color(red)(Cgamma - gamma) * h^color(red)(rgamma+psi)" "overset(?)(=)" "g^(e + color(red)(C)(color(red)(gamma) - e*(color(red)(C) - 1)^-1) -(color(red)(gamma) - e*(color(red)(C) - 1)^-1)) * h^(color(red)(r)(color(red)(gamma) - e*(color(red)(C) - 1)^-1) + (color(red)(psi) - e*color(red)(r)*(color(red)(C) - 1)^-1))`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`t_3" "overset(?)(=)" "g^e*(gCC)^(bar sigma)*h^(bar xi)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_3 = (gCC)^sigma*h^xi", "CC_Lambda = g^color(red)(C)*h^color(red)(r)" , "bar sigma = sigma - e*(color(red)(C) + 1)^-1" , "bar xi = xi - e*color(red)(r)*(color(red)(C) + 1)^-1`$

    $`(g(g^color(red)(C)*h^color(red)(r)))^sigma*h^xi" "overset(?)(=)" "g^e*(g(g^color(red)(C)*h^color(red)(r)))^(sigma - e*(color(red)(C) + 1)^-1)*h^(xi - e*color(red)(r)*(color(red)(C) + 1)^-1)`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`tilde t_1" "overset(?)(=)" "(tilde CC_r)^e*tilde h^(bar epsilon)*tilde g^(bar zeta)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`tilde t_1 = tilde h^color(red)(epsilon)*tilde g^color(red)(zeta)" , "tilde CC_r = tilde g^(color(red)(r_2))*tilde h^(color(red)(r_3))" , "bar epsilon = color(red)(epsilon) - e*color(red)(r_2)" , "bar zeta = color(red)(zeta) - e*color(red)(r_3)`$

    $`tilde h^color(red)(epsilon)*tilde g^color(red)(zeta)" "overset(?)(=)" "(tilde g^(color(red)(r_2))*tilde h^(color(red)(r_3)))^e*tilde h^(color(red)(epsilon) - e*color(red)(r_2))*tilde g^(color(red)(zeta) - e*color(red)(r_3))`$

    $`tilde h^color(red)(epsilon)*tilde g^color(red)(zeta)" "overset(?)(=)" "tilde g^(color(red)(r_2)*e)*tilde h^(color(red)(r_3)*e)*tilde h^(color(red)(epsilon) - e*color(red)(r_2))*tilde g^(color(red)(zeta) - e*color(red)(r_3))`$

    $`tilde h^color(red)(epsilon)*tilde g^color(red)(zeta)" "overset(?)(=)" "tilde g^(color(red)(r_2)*e + color(red)(zeta) - e*color(red)(r_3))*tilde h^(color(red)(r_3)*e + color(red)(epsilon) - e*color(red)(r_2))`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`tilde t_2" "overset(?)(=)" "(tilde CC_C)^e*tilde h^(bar alpha)*tilde g^(bar eta)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`tilde t_2 = tilde h^color(red)(alpha)*tilde g^color(red)(eta)" , "tilde CC_C = tilde g^color(red)(C)*tilde h^(color(red)(r_1))" , "bar alpha = color(red)(alpha) - e*color(red)(C)" , "bar eta = color(red)(eta) - e*color(red)(r_1)`$

    $`tilde h^color(red)(alpha)*tilde g^color(red)(eta)" "overset(?)(=)" "(tilde g^color(red)(C)*tilde h^(color(red)(r_1)))^e*tilde h^(color(red)(alpha) - e*color(red)(C))*tilde g^(color(red)(eta) - e*color(red)(r_1))`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`tilde t_3" "overset(?)(=)" "(Lambda')^e*(tilde CC_w)^(bar alpha)*tilde h^(-bar beta)`$</strong>
  </summary>
  <div className="nx-p-2">
    asdadsasd
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`tilde t_4" "overset(?)(=)" "(tilde CC_r)^(bar alpha)*tilde h^(-bar delta)*tilde g^(-bar beta)`$</strong>
  </summary>
  <div className="nx-p-2">
    asdadsasd
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`bar alpha" "overset(?)(in)" "[-B*2^(lambda'+lambda''+1), B*2^(lambda'+lambda''+1)]`$</strong>
  </summary>
  <div className="nx-p-2">
    asdadsasd
  </div>
</details>

#### Proof of Commitment opening ability

Having proven that $`CC_Lambda`$ commits to a value $`C`$ that is contained within the RSA accumulator, we next have to proof that we know of such $`C = g^S * h^r`$ that is committed to a serial number $`S`$ that we'll be revealing. To do that, you guessed it, we need yet another commitment $`CC_S`$ that is committed to $`C`$ as well:

$`CC_S = hat g^color(red)(C) * hat h^color(red)(w) = hat g^(g^S*h^color(red)(r)) * hat h^color(red)(w)`$

The complication here is that $`C`$ is a secret value and also an exponent of the accumulator's group, for which we need to prove that we're able to open the commitment $`C`$ (ie. proving knowledge of $`r`$) without revealing it. This requires a double-discrete logarithm proof.

| Prover                                                                | Verifier                                        |
| --------------------------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, h, hat g, hat h, CC_S, S, color(red)(C), color(red)(w), color(red)(r))`$ | Knows $`(g, h, hat g, hat h, CC_S, S)`$ |
| Chooses random values $`(color(red)(alpha_i), color(red)(beta_i))`$   | |
| $`t_i = hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)`$| |    
| Sends $`(t_i) Rightarrow`$                                            | Knows $`(g, h, hat g, hat h, CC_S, S, t_i)`$ |
|                                                                       | Chooses random challenge boolean $`e_i in {0, 1}`$ |
| Knows $`(g, h, hat g, hat h, CC_S, S, color(red)(C), color(red)(w), color(red)(r), color(red)(alpha_i), color(red)(beta_i), t_i, e_i)`$ | $`Leftarrow`$ Sends $`e_i`$ 
| $`"if ("e_i = 0") then: "bar alpha_i = color(red)(alpha_i)" , "bar beta_i = color(red)(beta_i)`$  | |
| $`"else: "bar alpha_i = color(red)(alpha_i) - color(red)(r)" , "bar beta_i = color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r))`$  | |
| Sends $`(bar alpha_i, bar beta_i) Rightarrow`$                        | Knows $`(g, h, hat g, hat h, CC_S, S, t_i, e_i, bar alpha_i, bar beta_i)`$ |
|                                                                       | $`"if ("e_i = 0") then: "t_i" "overset(?)(=)" "hat g^(g^S*h^bar alpha_i) * hat h^bar beta_i`$ |
|                                                                       | $`"else: "t_i" "overset(?)(=)" "(CC_S)^(h^bar alpha_i) * hat h^bar beta_i`$ |

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`e_i = 0": "t_i" "overset(?)(=)" "hat g^(g^S*h^bar alpha_i) * hat h^bar beta_i`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_i = hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" , "bar alpha_i = color(red)(alpha_i)" , "bar beta_i = color(red)(beta_i)`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(✓)(=)" "hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`e_i = 1": "t_i" "overset(?)(=)" "(CC_S)^(h^bar alpha_i) * hat h^bar beta_i`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_i = hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" , "bar alpha_i = color(red)(alpha_i) - color(red)(r)" , "bar beta_i = color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r))", "CC_S = hat g^(g^S*h^color(red)(r)) * hat h^color(red)(w)`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(?)(=)" "(CC_S)^(h^(color(red)(alpha_i) - color(red)(r))) * hat h^(color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r)))`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(?)(=)" "(hat g^(g^S*h^color(red)(r)) * hat h^color(red)(w))^(h^(color(red)(alpha_i) - color(red)(r))) * hat h^(color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r)))`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(?)(=)" "hat g^(g^S*h^(color(red)(r))*(h^(color(red)(alpha_i) - color(red)(r)))) * hat h^(color(red)(w)*(h^(color(red)(alpha_i) - color(red)(r)))) * hat h^(color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r)))`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(?)(=)" "hat g^(g^S*h^(color(red)(r)+color(red)(alpha_i) - color(red)(r))) * hat h^(color(red)(w)*h^(color(red)(alpha_i) - color(red)(r))+color(red)(beta_i) - color(red)(w)*h^(color(red)(alpha_i) - color(red)(r)))`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(?)(=)" "hat g^(g^S*h^(cancel(color(red)(r))+color(red)(alpha_i) cancel(- color(red)(r)))) * hat h^(cancel(color(red)(w)*h^(color(red)(alpha_i) - color(red)(r))) + color(red)(beta_i) cancel(- color(red)(w)*h^(color(red)(alpha_i) - color(red)(r))))`$

    $`hat g^(g^S*h^color(red)(alpha_i)) * hat h^color(red)(beta_i)" "overset(✓)(=)" "hat g^(g^S*h^(color(red)(alpha_i))) * hat h^(color(red)(beta_i))`$
  </div>
</details>

(what generators are these? are ANY of the generators even the same? is w the witness?)

coin flips, in rounds, but all the rounds can be done in parallel





#### Proof of Commitment sameness

<Callout>
  If you were under the impression that we'd be done after two proofs, you wouldn't be alone. After all, there was no paper published on Zerocoin that mentioned the existence of a third proof, the only way to know about it was reading the actual implementation within the libzerocoin library. Most cryptographers aren't exactly coders, and most coders aren't exactly cryptographers. When cryptographers look for cryptographic flaws, they do so less within the actual code. And when coders review the actual code, they're usually not looking for cryptographic mistakes but rather for implementation issues.

  It happened as it was bound to happen: Someone discovered a cryptographic flaw within libzerocoin and promptly started exploiting cryptocurrencies using it. Some currencies implemented a hotfix, others turned off their chain's Zerocoin functionality and never turned it on again. Zcoin was in a bit of a better position: They were already working on replacing the Zerocoin Protocol with Sigma and launched it on their mainnet not long after the attack. 
</Callout>

So far, the first proof shows that the commitment $`C`$ is indeed within the accumulator, representing a validly minted Zerocoin. The second proof shows that $`C`$ really commits to a serial number $`S`$, which, since already redeemed commitments aren't being removed from the accumulator, is remembered in order to prevent double spending. What's missing is a proof showing that both of them are even talking about the same commitment $`C`$. Without this, one could re-use the same commitment for the first proof over and over again (assuming that it really was added to the accumulator), but use some completely different commitment for the serial number (assuming that serial number had not been used yet, not necessary for the commitment to actually be accumulated).

$$
`bb"ZKPoK"{(color(red)(C_A), color(red)(C_B), color(red)(r), color(red)(w)): CC_Lambda = g^color(red)(C_A)*h^color(red)(r) ^^ CC_S = hat g^color(red)(C_B) * hat h^color(red)(w) ^^ color(red)(C_A) = color(red)(C_B)}`
$$

$$
`color(red)(C) = color(red)(C_A) = color(red)(C_B)`
$$

| Prover                                                                | Verifier                                        |
| --------------------------------------------------------------------: | :---------------------------------------------- |
| Knows $`(g, h, hat g, hat h, CC_Lambda, CC_S, color(red)(C), color(red)(w), color(red)(r))`$ | Knows $`(g, h, hat g, hat h, CC_Lambda, CC_S)`$ |
| Chooses random values $`(color(red)(alpha), color(red)(beta), color(red)(gamma))`$ | |
| $`t_1 = g^color(red)(alpha)*h^color(red)(beta)`$                      | |
| $`t_2 = hat g^color(red)(alpha)* hat h^color(red)(gamma)`$             | |
| Sends $`(t_1, t_2) Rightarrow`$                                       | Knows $`(g, h, hat g, hat h, CC_Lambda, CC_S, t_1, t_2)`$ |
|                                                                       | Chooses random challenge $`e`$ |
| Knows $`(g, h, hat g, hat h, CC_Lambda, CC_S, color(red)(C), color(red)(w), color(red)(r), color(red)(alpha), color(red)(beta), color(red)(gamma), t_1, t_2, e)`$ | $`Leftarrow`$ Sends $`e`$ 
| $`bar alpha = color(red)(alpha) + color(red)(C) * e`$                 | |
| $`bar beta = color(red)(beta) + color(red)(r) * e`$                   | |
| $`bar gamma = color(red)(gamma) + color(red)(w) * e`$                 | |
| Sends $`(bar alpha, bar beta, bar gamma) Rightarrow`$                 | Knows $`(g, h, hat g, hat h, CC_Lambda, CC_S, t_1, t_2, e, bar alpha, bar beta, bar gamma)`$ |
|                                                                       | $`t_1 " "overset(?)(=)" "g^bar alpha * h^bar beta * (CC_Lambda)^(-e)`$ |
|                                                                       | $`t_2 " "overset(?)(=)" "hat g^bar alpha * hat h^bar gamma * (CC_S)^(-e)`$ |

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`t_1 " "overset(?)(=)" "g^bar alpha * h^bar beta * (CC_Lambda)^(-e)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_1 = g^color(red)(alpha)*h^color(red)(beta)" , "bar alpha = color(red)(alpha) + color(red)(C) * e" , "bar beta = color(red)(beta) + color(red)(r) * e" , "CC_Lambda = g^color(red)(C)*h^color(red)(r)`$

    $`g^color(red)(alpha)*h^color(red)(beta) " "overset(?)(=)" "g^(color(red)(alpha) + color(red)(C) * e) * h^(color(red)(beta) + color(red)(r) * e) * (g^color(red)(C)*h^color(red)(r))^(-e)`$

    $`g^color(red)(alpha)*h^color(red)(beta) " "overset(?)(=)" "g^(color(red)(alpha) + ecolor(red)(C)) * h^(color(red)(beta) + ecolor(red)(r)) * g^(-ecolor(red)(C))*h^(-ecolor(red)(r))`$

    $`g^color(red)(alpha)*h^color(red)(beta) " "overset(?)(=)" "g^(color(red)(alpha) + ecolor(red)(C) - ecolor(red)(C)) * h^(color(red)(beta) + ecolor(red)(r)-ecolor(red)(r))`$

    $`g^color(red)(alpha)*h^color(red)(beta) " "overset(?)(=)" "g^(color(red)(alpha) + cancel(ecolor(red)(C) - ecolor(red)(C))) * h^(color(red)(beta) + cancel(ecolor(red)(r)-ecolor(red)(r)))`$

    $`g^color(red)(alpha)*h^color(red)(beta) " "overset(✓)(=)" "g^(color(red)(alpha)) * h^(color(red)(beta))`$
  </div>
</details>

<details className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4">
  <summary>
    <strong className="text-lg">$`t_2 " "overset(?)(=)" "hat g^bar alpha * hat h^bar gamma * (CC_S)^(-e)`$</strong>
  </summary>
  <div className="nx-p-2">
    Substitute $`t_2 = hat g^color(red)(alpha)* hat h^color(red)(gamma)" , "bar alpha = color(red)(alpha) + color(red)(C) * e" , "bar gamma = color(red)(gamma) + color(red)(w) * e" , "CC_S = hat g^color(red)(C) * hat h^color(red)(w)`$

    $`hat g^color(red)(alpha)* hat h^color(red)(gamma) " "overset(?)(=)" "hat g^(color(red)(alpha) + color(red)(C) * e) * hat h^(color(red)(gamma) + color(red)(w) * e) * (hat g^color(red)(C) * hat h^color(red)(w))^(-e)`$

    $`hat g^color(red)(alpha)*hat h^color(red)(gamma) " "overset(?)(=)" "hat g^(color(red)(alpha) + ecolor(red)(C)) * hat h^(color(red)(gamma) + ecolor(red)(w)) * hat g^(-ecolor(red)(C))* hat h^(-ecolor(red)(w))`$

    $`hat g^color(red)(alpha)*hat h^color(red)(gamma) " "overset(?)(=)" "hat g^(color(red)(alpha) + ecolor(red)(C) - ecolor(red)(C)) * hat h^(color(red)(gamma) + ecolor(red)(w)-ecolor(red)(w))`$

    $`hat g^color(red)(alpha)*hat h^color(red)(gamma) " "overset(?)(=)" "hat g^(color(red)(alpha) + cancel(ecolor(red)(C) - ecolor(red)(C))) * hat h^(color(red)(gamma) + cancel(ecolor(red)(w)-ecolor(red)(w)))`$

    $`hat g^color(red)(alpha)*hat h^color(red)(gamma) " "overset(✓)(=)" "hat g^(color(red)(alpha)) * hat h^(color(red)(gamma))`$
  </div>
</details>


## Appendix


### Tech-Tree

![Cryptographic Tech-Tree Diagram for Zerocoin](./crypto-tech-diagram-zerocoin.jpg)

*Note that this Tech-Tree omits detailed dependencies that are not specific to Zerocoin to maintain readability.*

### History

<Timeline>
  <Year year='2013'>
    * [Zerocoin Whitepaper](https://ieeexplore.ieee.org/document/6547123/) published in IEEE Symposium on Security and Privacy
  </Year>
  <Year year='2014'>
    * First stand-alone implementation as [Moneta](https://web.archive.org/web/20150203221850/https://moneta.cash/about.html)
  </Year>
  <Year year='2015'>
    * Moneta testnet launched
  </Year>
  <Year year='2016'>
    * Zcoin mainnet launched (renamed from Moneta)
    * [PIVX](https://web.archive.org/web/20180827061438/https://pivx.org/what-is-pivx/), a Proof of Stake chain, launches with Zerocoin implemented
    * [Zoin](https://bitcointalk.org/index.php?topic=1671060.0) (later Noir), a Zcoin fork, launches without founder rewards
  </Year>
  <Year year='2017'>
    * [Ian Miers' master thesis](https://jscholarship.library.jhu.edu/server/api/core/bitstreams/791c3d9d-804b-4534-a25e-86e07fdfee14/content) published, containing missing proofs
    * [Zcoin suffers inflation attack](https://web.archive.org/web/20171115184742/http://zcoin.io/zcoin-hard-fork-statement/) due to implementation issues
    * [HexxCoin](https://coincentral.com/what-is-hexxcoin-a-beginners-guide/) launches with Zerocoin implemented
  </Year>
  <Year year='2018'>
    * [Audit](https://www.chaac.tf.fau.eu/2018/04/12/zerocoinzcoinpivxzoinsmartcashhexxcoin-attack/) revealed implementation issues in libzerocoin allowing theft and inflation attackspublished, containing missing proofs
    * Audit also revealed a fundamental cryptographic flaw in "[Burning Zerocoins for fun and profit](https://www.chaac.tf.fau.de/files/2018/04/attack-cryptocur.pdf)"
    * Zcoin introduced Dandelion++ protocol, hiding sender IP addresses via TOR/VPN
    * [SmartCash](https://bitcointalk.org/index.php?topic=2560430) launches
  </Year>
  <Year year='2019'>
    * [Veil](https://bitcointalk.org/index.php?topic=5065331.0) launches enforcing all transaction to use Zerocoin
    * [Cryptographic flaw in proving system](https://web.archive.org/web/20190430131937/https://zcoin.io/cryptographic-description-of-zerocoin-attack/) was exploited for inflation attack
    * Zcoin departs from Zerocoin Protocol with [Sigma Protocol](https://eprint.iacr.org/2014/764.pdf)
  </Year>
  <Year year='2020'>
    * Zcoin rebrands to Firo
  </Year>
  <Year year='2021'>
    * Firo activated [Lelantus Protocol](https://firo.org/2021/01/15/lelantus-activated-mainnet.html) on mainnet
    * Firo implemented [Receiver Address Privacy (RAP)](https://firo.org/2021/06/09/introducing-receiver-address-privacy-for-firo.html), an adaption of BIP47
  </Year>
  <Year year='2024'>
    * Firo activates [Lelantus Spark protocol](https://firo.org/2021/08/24/presenting-lelantus-spark.html) on mainnet
  </Year>
</Timeline>

### References

<References>
  <Reference reference='1'>
    Miers, I., Garman, C., Green, M. and Rubin, A.D., 2013, May. *Zerocoin: Anonymous distributed e-cash from bitcoin.* In 2013 IEEE Symposium on Security and Privacy (pp. 397-411). IEEE.
  </Reference>
  <Reference reference='2'>
    Satoshi Nakamoto, 2008, *Bitcoin: A Peer-to-Peer Electronic Cash System*, https://bitcoin.org/bitcoin.pdf
  </Reference>
  <Reference reference='3'>
    Sander, T. and Ta-Shma, A., 1999. *Auditable, anonymous electronic cash*. In Advances in Cryptology—CRYPTO’99: 19th Annual International Cryptology Conference Santa Barbara, California, USA, August 15–19, 1999 Proceedings 19 (pp. 555-572). Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='4'>
    Chaum, D., Fiat, A. and Naor, M., 1990. Untraceable electronic cash. In Advances in Cryptology—CRYPTO’88: Proceedings 8 (pp. 319-327). Springer New York.
  </Reference>
  <Reference reference='5'>
    Chaum, D., 1983, August. *Blind signatures for untraceable payments*. In Advances in Cryptology: Proceedings of Crypto 82 (pp. 199-203). Boston, MA: Springer US.
  </Reference>
  <Reference reference='6'>
    Rivest, R.L., Shamir, A. and Adleman, L., 1978. *A method for obtaining digital signatures and public-key cryptosystems*. Communications of the ACM, 21(2), pp.120-126.
  </Reference>
  <Reference reference='7'>
    Diffie, W. and Hellman, M.E., 1676. *New directions in cryptography*. In Democratizing Cryptography: The Work of Whitfield Diffie and Martin Hellman (pp. 365-390).
  </Reference>
  <Reference reference='8'>
    Camenisch, J. and Lysyanskaya, A., 2002. *Dynamic accumulators and application to efficient revocation of anonymous credentials*. In Advances in Cryptology—CRYPTO 2002: 22nd Annual International Cryptology Conference Santa Barbara, California, USA, August 18–22, 2002 Proceedings 22 (pp. 61-76). Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='9'>
    Barić, N. and Pfitzmann, B., 1997, May. *Collision-free accumulators and fail-stop signature schemes without trees*. In International conference on the theory and applications of cryptographic techniques (pp. 480-494). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='10'>
    Benaloh, J. and De Mare, M., 1993, May. *One-way accumulators: A decentralized alternative to digital signatures.* In Workshop on the Theory and Application of of Cryptographic Techniques (pp. 274-285). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='11'>
    Maxwell, G. and Poelstra, A., 2015. *Borromean ring signatures*. https://raw.githubusercontent.com/Blockstream/borromean_paper/master/borromean_draft_0.01_34241bb.pdf
  </Reference>
  <Reference reference='12'>
    Schnorr, C.P., 1990. *Efficient identification and signatures for smart cards*. In Advances in Cryptology—CRYPTO’89 Proceedings 9 (pp. 239-252). Springer New York.
  </Reference>
  <Reference reference='13'>
    Cramer, R., Damgård, I. and Schoenmakers, B., 1994, August. *Proofs of partial knowledge and simplified design of witness hiding protocols*. In Annual International Cryptology Conference (pp. 174-187). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='14'>
    Camenisch, J. and Michels, M., 1999. *Proving in zero-knowledge that a number is the product of two safe primes.* In Advances in Cryptology—EUROCRYPT’99: International Conference on the Theory and Application of Cryptographic Techniques Prague, Czech Republic, May 2–6, 1999 Proceedings 18 (pp. 107-122). Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='15'>
    Camenisch, J., 1998. *Group signature schemes and payment systems based on the discrete logarithm problem* (Doctoral dissertation, ETH Zurich).
  </Reference>
  <Reference reference='16'>
    Brands, S., 1997, May. *Rapid demonstration of linear relations connected by boolean operators*. In International Conference on the Theory and Applications of Cryptographic Techniques (pp. 318-333). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='17'>
    Fiat, A. and Shamir, A., 1986, August. *How to prove yourself: Practical solutions to identification and signature problems*. In Conference on the theory and application of cryptographic techniques (pp. 186-194). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='18'>
    Chase, M. and Lysyanskaya, A., 2006. *On signatures of knowledge*. In Advances in Cryptology-CRYPTO 2006: 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006. Proceedings 26 (pp. 78-96). Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='19'>
    Ruffing, T., Thyagarajan, S.A., Ronge, V. and Schroder, D., 2018, June. (Short Paper) *Burning Zerocoins for Fun and for Profit-A Cryptographic Denial-of-Spending Attack on the Zerocoin Protocol*. In 2018 Crypto Valley Conference on Blockchain Technology (CVCBT) (pp. 116-119). IEEE.
  </Reference>
  <Reference reference='20'>
    Danezis, G., Fournet, C., Kohlweiss, M. and Parno, B., 2013, November. *Pinocchio coin: building zerocoin from a succinct pairing-based proof system*. In Proceedings of the First ACM workshop on Language support for privacy-enhancing technologies (pp. 27-30).
  </Reference>
  <Reference reference='21'>
    Reuben Yap, 2017, April, *Zcoin moving beyond trusted setup in Zerocoin*, https://firo.org/id/2017/04/21/zcoin-moving-beyond-trusted-setup-in-zerocoin.html 
  </Reference>
  <Reference reference='22'>
    Miers, I., 2017. *Decentralized anonymous payments* (Doctoral dissertation, Johns Hopkins University).
  </Reference>
  <Reference reference='23'>
    Siri Dahle, 2018, June, *Anonymity for Decentralized Electronic Cash Systems*, Master of Science thesis at Norwegian University of Science and Technology Department of Mathematical Sciences.
  </Reference>
  <Reference reference='24'>
    Matthew Green, 2016, July, *Zerocoin: Anonymous Distributed E-Cash from Bitcoin*, lecture at Microsoft Research, https://www.youtube.com/watch?v=4uWlqPIb1zw
  </Reference>
  <Reference reference='25'>
    Reuben Yap, 2019, May, *Zerocoin Critical Flaw Explained With Reuben of Zcoin Crypto*, Lark Davis, https://www.youtube.com/watch?v=FEoda23otIY
  </Reference>
  <Reference reference='26'>
    Tadhg Riorden, 2018m June, *Tadhg Riorden Explains Zerocoin Protocol at Bitcoin Wednesday*, Zeth: Zerocoin on Ethereum, Bitcoin Wednesday, https://www.youtube.com/watch?v=ZZyqkLDpc3A
  </Reference>
  <Reference reference='27'>
    Reuben Yap, 2019, April, *Cryptographic description of Zerocoin attack*, https://web.archive.org/web/20190430131937/https://zcoin.io/cryptographic-description-of-zerocoin-attack/
  </Reference>
  <Reference reference='28'>
    Christina Garman, Matthew Green, Ian Miers, and Aviel D Rubin. *Rational zero: Economic security for Zerocoin with everlasting anonymity*, on creating divisible coins and no longer having to have separate Zerocoins per denomination. In International Conference on Financial Cryptography and Data Security, pages
    140–155. Springer, 2014.
  </Reference>
  <Reference reference='29'>
    Groth, J. and Kohlweiss, M., 2015, April. *One-out-of-many proofs: Or how to leak a secret and spend a coin*, Zcoin's Sigma protocol. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (pp. 253-280). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='30'>
    Jivanyan, A., 2019. *Lelantus: Towards Confidentiality and Anonymity of Blockchain Transactions from Standard Assumptions*. IACR Cryptol. ePrint Arch., 2019, p.373. https://lelantus.io/
  </Reference>
  <Reference reference='31'>
    Binance Research (Etienne), 2020, Februrary, *An examination of the flaws in the Zerocoin protocol*, https://www.binance.com/en/research/analysis/zerocoin-flaws#2.-Historical-flaws-and-incidents-in-Zerocoin-based-cryptos
  </Reference>
  <Reference reference='32'>
    Reuben Yap, 2019, April, *Further Disclosure on Zerocoin vulnerability*, https://web.archive.org/web/20190501035025/https://zcoin.io/further-disclosure-on-zerocoin-vulnerability/
  </Reference>
  <Reference reference='32'>
    Reuben Yap, 2017, April, *Zcoin moving beyond trusted setup in Zerocoin*, https://firo.org/id/2017/04/21/zcoin-moving-beyond-trusted-setup-in-zerocoin.html
  </Reference>
  <Reference reference='33'>
    Reuben Yap, 2019, April, *Lelantus: Zcoin’s next gen privacy protocol*, https://web.archive.org/web/20190426131338/https://zcoin.io/lelantus-zcoin/
  </Reference>
  <Reference reference='34'>
    Reuben Yap, 2018, April, *A statement on the paper “Burning Zerocoins for fun and profit”*, https://web.archive.org/web/20180909001327/https://zcoin.io/statement-paper-burning-zerocoins-fun-profit/
  </Reference>
  <Reference reference='35'>
    Poramin Insom, 2017, November, *Zcoin hard fork statement*, https://web.archive.org/web/20171113112736/https://zcoin.io/zcoin-hard-fork-statement/
  </Reference>
  <Reference reference='36'>
    Merkle, R.C., 1987, August. *A digital signature based on a conventional encryption function*. In Conference on the theory and application of cryptographic techniques (pp. 369-378). Berlin, Heidelberg: Springer Berlin Heidelberg.
  </Reference>
  <Reference reference='37'>
    Dobson, S., Galbraith, S. and Smith, B., 2022. *Trustless unknown-order groups*. arXiv preprint arXiv:2211.16128.
  </Reference>
</References>